commit 1e00c4c23bcc25259f07584376820bd2192e5862
Author: s54zhang <s54zhang@student.cs.uwaterloo.ca>
Date:   Sun Jul 1 22:30:08 2012 -0400

    rename stuff to not use ui msg.

diff --git a/kernel/train/Driver.c b/kernel/train/Driver.c
index 04e280c..2b2d3c8 100644
--- a/kernel/train/Driver.c
+++ b/kernel/train/Driver.c
@@ -14,17 +14,16 @@
 // TODO, smaller Delay increments. and make better guess.
 
 static int com1;
-static int com2;
 static int ui;
 static int CC = 0;
 
 static int getStoppingDistance(Driver* me) {
-  return me->d[(int)me->uiMsg.speed][(int)me->uiMsg.speedDir][MAX_VAL];
+  return me->d[(int)me->speed][(int)me->speedDir][MAX_VAL];
 }
 
 // mm/s
 static int getVelocity(Driver* me){
-  return me->v[(int)me->uiMsg.speed][(int)me->uiMsg.speedDir];
+  return me->v[(int)me->speed][(int)me->speedDir];
 }
 
 static int getStoppingTime(Driver* me) {
@@ -38,12 +37,12 @@ static void getRoute(Driver* me, DriverMsg* msg) {
   // TODO use me->currPos
   Position currPos;
   currPos.landmark1.type = LANDMARK_SENSOR;
-  currPos.landmark1.num1 = me->uiMsg.lastSensorBox;
-  currPos.landmark1.num2 = me->uiMsg.lastSensorVal;
+  currPos.landmark1.num1 = me->lastSensorBox;
+  currPos.landmark1.num2 = me->lastSensorVal;
   currPos.landmark2.type = LANDMARK_SENSOR;
-  currPos.landmark2.num1 = me->uiMsg.nextSensorBox;
-  currPos.landmark2.num2 = me->uiMsg.nextSensorVal;
-  currPos.offset = me->uiMsg.distanceFromLastSensor;
+  currPos.landmark2.num1 = me->nextSensorBox;
+  currPos.landmark2.num2 = me->nextSensorVal;
+  currPos.offset = me->distanceFromLastSensor;
 
   trackmsg.position1 = currPos;
   trackmsg.position2 = msg->pos;
@@ -70,12 +69,12 @@ static void getRoute(Driver* me, DriverMsg* msg) {
 
 static int shouldStopNow(Driver* me) {
   int canUseLastSensor =
-      ( me->uiMsg.lastSensorBox == me->stopSensorBox &&
-        me->uiMsg.lastSensorVal == me->stopSensorVal
+      ( me->lastSensorBox == me->stopSensorBox &&
+        me->lastSensorVal == me->stopSensorVal
       ) || me->useLastSensorNow;
 
   if (canUseLastSensor) {
-    int d = me->distancePassStopSensorToStop - me->uiMsg.distanceFromLastSensor;
+    int d = me->distancePassStopSensorToStop - me->distanceFromLastSensor;
 
     if ((CC++ & 15) == 0) {
       PrintDebug(me->ui, "Navi Nagger. %d", d);
@@ -114,7 +113,7 @@ static void updateStopNode(Driver* me, int speed) {
   PrintDebug(me->ui, "calc stopping distance.");
 
   const int stoppingDistance =
-      me->d[speed][(int)me->uiMsg.speedDir][MAX_VAL];
+      me->d[speed][(int)me->speedDir][MAX_VAL];
   int stop = stoppingDistance;
   // Find the stopping distance for the stopNode.
   // S------L------L---|-----L---------R------F
@@ -149,7 +148,7 @@ static void updateStopNode(Driver* me, int speed) {
         //          |  |___ current position
         //          |______ distanceFromLastSensor
         me->useLastSensorNow = 1;
-        previousStop += me->uiMsg.distanceFromLastSensor;
+        previousStop += me->distanceFromLastSensor;
       }
       // Else..
       //     |---stopSensorBox
@@ -190,14 +189,14 @@ static void updateRoute(Driver* me, char box, char val) {
 }
 
 static void dynamicCalibration(Driver* me) {
-  if (me->uiMsg.lastSensorUnexpected) return;
-  if (me->uiMsg.speed == 0) return; // Cannot calibrate speed zero
+  if (me->lastSensorUnexpected) return;
+  if (me->speed == 0) return; // Cannot calibrate speed zero
 
-  int dTime = me->uiMsg.lastSensorPredictedTime - me->uiMsg.lastSensorActualTime;
+  int dTime = me->lastSensorPredictedTime - me->lastSensorActualTime;
   if (dTime > 1000) return;
-  int velocity = me->calibrationDistance * 100 * 1000 / (me->uiMsg.lastSensorActualTime - me->calibrationStart);
-  int originalVelocity = me->v[(int)me->uiMsg.speed][(int)me->uiMsg.speedDir];
-  me->v[(int)me->uiMsg.speed][(int)me->uiMsg.speedDir]
+  int velocity = me->calibrationDistance * 100 * 1000 / (me->lastSensorActualTime - me->calibrationStart);
+  int originalVelocity = me->v[(int)me->speed][(int)me->speedDir];
+  me->v[(int)me->speed][(int)me->speedDir]
       = (originalVelocity * 8 + velocity * 2) / 10;
 }
 
@@ -219,18 +218,18 @@ static void trainSetSpeed(const int speed, const int stopTime, const int delayer
       msg[0] = (char)speed;
       Putstr(com1, msg, 2);
     }
-    if (speed > me->uiMsg.speed) {
-      me->uiMsg.speedDir = ACCELERATE;
-    } else if (speed < me->uiMsg.speed) {
-      me->uiMsg.speedDir = DECELERATE;
+    if (speed > me->speed) {
+      me->speedDir = ACCELERATE;
+    } else if (speed < me->speed) {
+      me->speedDir = DECELERATE;
     }
-    me->uiMsg.speed = speed;
+    me->speed = speed;
   } else {
-    PrintDebug(me->ui, "Reverse... %d \n", me->uiMsg.speed);
+    PrintDebug(me->ui, "Reverse... %d \n", me->speed);
     DriverMsg delayMsg;
     delayMsg.type = SET_SPEED;
     delayMsg.timestamp = stopTime;
-    delayMsg.data2 = (signed char)me->uiMsg.speed;
+    delayMsg.data2 = (signed char)me->speed;
     PrintDebug(me->ui, "Using delayer: %d for %d \n", me->delayer, stopTime);
 
     Reply(me->delayer, (char*)&delayMsg, sizeof(DriverMsg));
@@ -239,8 +238,8 @@ static void trainSetSpeed(const int speed, const int stopTime, const int delayer
     msg[1] = (char)me->trainNum;
 
     Putstr(com1, msg, 2);
-    me->uiMsg.speed = 0;
-    me->uiMsg.speedDir = DECELERATE;
+    me->speed = 0;
+    me->speedDir = DECELERATE;
   }
 }
 
@@ -293,29 +292,16 @@ static void trainDelayer() {
   }
 }
 
-static void trainUiNagger() {
+static void trainNagger() {
   char timename[] = TIMESERVER_NAME;
   int timeserver = WhoIs(timename);
   int parent = MyParentsTid();
 
   DriverMsg msg;
-  msg.type = UI_NAGGER;
-  for (;;) {
-    Delay(20, timeserver); // .2 seconds
-    msg.timestamp = Time(timeserver) * 10;
-    Send(parent, (char*)&msg, sizeof(DriverMsg), (char*)1, 0);
-  }
-}
-
-static void trainNavigateNagger() {
-  char timename[] = TIMESERVER_NAME;
-  int timeserver = WhoIs(timename);
-  int parent = MyParentsTid();
-
-  DriverMsg msg;
-  msg.type = NAVIGATE_NAGGER;
+  msg.type = NAGGER;
   for (;;) {
     Delay(5, timeserver); // .15 seconds
+    msg.timestamp = Time(timeserver);
     Send(parent, (char*)&msg, sizeof(DriverMsg), (char*)1, 0);
   }
 }
@@ -326,49 +312,53 @@ static void initDriver(Driver* me) {
   ui = me->ui;
   char trackName[] = TRACK_NAME;
   me->trackManager = WhoIs(trackName);
+  char timename[] = TIMESERVER_NAME;
+  me->timeserver = WhoIs(timename);
+
   me->route.length = 0;
   me->stopCommited = 0; // haven't enabled speed zero yet.
   me->useLastSensorNow = 0;
 
-  char timename[] = TIMESERVER_NAME;
-  me->timeserver = WhoIs(timename);
 
   DriverInitMsg init;
   int controller;
   Receive(&controller, (char*)&init, sizeof(DriverInitMsg));
   Reply(controller, (char*)1, 0);
   me->trainNum = init.trainNum;
-  me->uiMsg.nth = init.nth;
+  me->uiNth = init.nth;
 
-  me->uiMsg.speed = 0;
-  me->uiMsg.speedDir = ACCELERATE;
-  me->uiMsg.distanceToNextSensor = 0;
-  me->uiMsg.distanceFromLastSensor = 0;
-  me->uiMsg.lastSensorActualTime = 0;
+  me->speed = 0;
+  me->speedDir = ACCELERATE;
+  me->distanceToNextSensor = 0;
+  me->distanceFromLastSensor = 0;
+  me->lastSensorActualTime = 0;
 
   me->delayer = Create(1, trainDelayer);
-  me->uiNagger = Create(3, trainUiNagger);
   me->sensorWatcher = Create(3, trainSensor);
-  me->navigateNagger = Create(2, trainNavigateNagger);
+  me->nagger = Create(2, trainNagger);
   me->routeRemaining = -1;
 
-  me->uiMsg.type = UPDATE_TRAIN;
-
   initStoppingDistance((int*)me->d);
   initVelocity((int*)me->v);
+  trainSetSpeed(0, 0, 0, me); // Make train speed zero.
 }
 
-static void sendUiReport(Driver* me, int time) {
-  me->uiMsg.velocity = getVelocity(me) / 100;
+static void updatePosition(Driver* me, int time) {
   if (time) {
     // In mm
     int dPosition = (time - me->reportTime) * getVelocity(me) / 100000;
     me->reportTime = time;
-    me->uiMsg.distanceFromLastSensor += dPosition;
-    me->uiMsg.distanceToNextSensor -= dPosition;
+    me->distanceFromLastSensor += dPosition;
+    me->distanceToNextSensor -= dPosition;
   }
+}
+
+static void sendUiReport(Driver* me) {
+  TrainUiMsg msg;
+  msg.type = UPDATE_TRAIN;
+  msg.nth = me->uiNth;
 
-  Send(me->ui, (char*)&(me->uiMsg), sizeof(TrainUiMsg), (char*)1, 0);
+  Send(me->ui, (char*)&msg, sizeof(TrainUiMsg), (char*)1, 0);
 }
 
 static void driver() {
@@ -377,6 +367,7 @@ static void driver() {
 
   // used to store one set_route msg when train's current position is unknown
   int hasTempRouteMsg = 0;
+  int naggCount = 0;
   DriverMsg tempRouteMsg;
 
   for (;;) {
@@ -393,7 +384,7 @@ static void driver() {
 
     switch (msg.type) {
       case GET_SPEED: {
-        Reply(replyTid, (char*)&me.uiMsg.speed, 4);
+        Reply(replyTid, (char*)&me.speed, 4);
         break;
       }
       case SET_SPEED: {
@@ -402,9 +393,9 @@ static void driver() {
                       (msg.data3 == DELAYER),
                       &me);
         if (msg.data3 != DELAYER) {
-          //printff(com2, "Replied to %d\n", replyTid);
+          //PrintDebug(me.ui, "Replied to %d\n", replyTid);
           Reply(replyTid, (char*)1, 0);
-          sendUiReport(&me, 0); // Don't update time
+          sendUiReport(&me);
           break;
         } else if (me.route.length != 1) {
           // Delayer came back. Reverse command completed
@@ -420,43 +411,41 @@ static void driver() {
         PrintDebug(me.ui, "delayer come back.");
         break;
       }
-      case UI_NAGGER: {
-        sendUiReport(&me, msg.timestamp);
-        break;
-      }
       case SENSOR_TRIGGER: {
-        if (msg.data2 != me.uiMsg.nextSensorBox || msg.data3 != me.uiMsg.nextSensorVal) {
-          me.uiMsg.lastSensorUnexpected = 1;
+        if (msg.data2 != me.nextSensorBox || msg.data3 != me.nextSensorVal) {
+          me.lastSensorUnexpected = 1;
           //reRoute(&me, msg.data2, msg.data3); // TODO
         } else {
-          me.uiMsg.lastSensorUnexpected = 0;
+          me.lastSensorUnexpected = 0;
         }
         updateRoute(&me, msg.data2, msg.data3);
-        me.uiMsg.lastSensorBox = msg.data2; // Box
-        me.uiMsg.lastSensorVal = msg.data3; // Val
-        me.uiMsg.lastSensorActualTime = msg.timestamp;
+
+        me.lastSensorBox = msg.data2; // Box
+        me.lastSensorVal = msg.data3; // Val
+        me.lastSensorActualTime = msg.timestamp;
         dynamicCalibration(&me);
-        me.uiMsg.lastSensorPredictedTime = me.uiMsg.nextSensorPredictedTime;
+        me.lastSensorPredictedTime = me.nextSensorPredictedTime;
 
         TrackNextSensorMsg tMsg;
         TrackMsg qMsg;
         qMsg.type = QUERY_NEXT_SENSOR_FROM_SENSOR;
         qMsg.landmark1.type = LANDMARK_SENSOR;
-        qMsg.landmark1.num1 = me.uiMsg.lastSensorBox;
-        qMsg.landmark1.num2 = me.uiMsg.lastSensorVal;
+        qMsg.landmark1.num1 = me.lastSensorBox;
+        qMsg.landmark1.num2 = me.lastSensorVal;
         Send(me.trackManager, (char*)&qMsg, sizeof(TrackMsg),
               (char*)&tMsg, sizeof(TrackNextSensorMsg));
         me.calibrationStart = msg.timestamp;
         me.calibrationDistance = tMsg.dist;
-        me.uiMsg.distanceFromLastSensor = 0;
-        me.uiMsg.distanceToNextSensor = tMsg.dist;
+        me.distanceFromLastSensor = 0;
+        me.distanceToNextSensor = tMsg.dist;
         me.reportTime = msg.timestamp;
-        me.uiMsg.nextSensorBox = tMsg.sensor.num1;
-        me.uiMsg.nextSensorVal = tMsg.sensor.num2;
-        me.uiMsg.nextSensorPredictedTime =
-          msg.timestamp + me.uiMsg.distanceToNextSensor*100000 / getVelocity(&me) - 50; // 50 ms delay for sensor query.
+        me.nextSensorBox = tMsg.sensor.num1;
+        me.nextSensorVal = tMsg.sensor.num2;
+        me.nextSensorPredictedTime =
+          msg.timestamp + me.distanceToNextSensor*100000 / getVelocity(&me) - 50; // 50 ms delay for sensor query.
 
-        sendUiReport(&me, msg.timestamp);
+        updatePosition(&me, msg.timestamp);
+        sendUiReport(&me);
         if (hasTempRouteMsg) {
           getRoute(&me, &tempRouteMsg);
           updateStopNode(&me, tempRouteMsg.data2);
@@ -464,32 +453,37 @@ static void driver() {
         }
         break;
       }
-      case NAVIGATE_NAGGER: {
-        if (me.routeRemaining == -1) break;
-
-        if (!me.stopCommited) {
-          if (shouldStopNow(&me)) {
-            if (me.route.nodes[me.stopNode].num == REVERSE) {
-              PrintDebug(me.ui, "Navi reversing.");
-              const int speed = -1;
-              trainSetSpeed(speed, getStoppingTime(&me), 0, &me);
+      case NAGGER: {
+        updatePosition(&me, msg.timestamp);
+
+        if (me.routeRemaining != -1) {
+          if (!me.stopCommited) {
+            if (shouldStopNow(&me)) {
+              if (me.route.nodes[me.stopNode].num == REVERSE) {
+                PrintDebug(me.ui, "Navi reversing.");
+                const int speed = -1;
+                trainSetSpeed(speed, getStoppingTime(&me), 0, &me);
+              }
+              else {
+                PrintDebug(me.ui, "Navi Nagger stopping.");
+                const int speed = 0;  // Set speed zero.
+                trainSetSpeed(speed, getStoppingTime(&me), 0, &me);
+                me.route.length = 0; // Finished the route.
+              }
+              me.stopCommited = 1;
+              me.useLastSensorNow = 0;
             }
-            else {
-              PrintDebug(me.ui, "Navi Nagger stopping.");
-              const int speed = 0;  // Set speed zero.
-              trainSetSpeed(speed, getStoppingTime(&me), 0, &me);
-              me.route.length = 0; // Finished the route.
-            }
-            me.stopCommited = 1;
-            me.useLastSensorNow = 0;
           }
         }
+        if ((naggCount++ & 3) == 0) {
+          sendUiReport(&me); // Update ui once in a while
+        }
         break;
       }
       case SET_ROUTE: {
         Reply(replyTid, (char*)1, 0);
         me.stopCommited = 0;
-        if (me.uiMsg.lastSensorActualTime > 0) {
+        if (me.lastSensorActualTime > 0) {
           getRoute(&me, &msg);
           updateStopNode(&me, msg.data2);
           trainSetSpeed(msg.data2, 0, 0, &me);
@@ -514,9 +508,7 @@ static void trainController() {
   RegisterAs(trainName);
 
   char com1Name[] = IOSERVERCOM1_NAME;
-  char com2Name[] = IOSERVERCOM2_NAME;
   com1 = WhoIs(com1Name);
-  com2 = WhoIs(com2Name);
 
   int nth = 0;
   int trainTid[80]; // Train num -> train tid
diff --git a/kernel/train/Driver.h b/kernel/train/Driver.h
index f2ecef9..6ac3fbb 100644
--- a/kernel/train/Driver.h
+++ b/kernel/train/Driver.h
@@ -11,11 +11,10 @@
 #define SET_SPEED  0
 #define GET_SPEED  1
 #define GOTO_DEST  2
-#define UI_NAGGER  3
+#define NAGGER  3
 #define DELAYER    4
 #define SENSOR_TRIGGER 5
 #define SET_ROUTE  6
-#define NAVIGATE_NAGGER 7
 
 typedef struct DriverInitMsg {
   int nth;
@@ -36,11 +35,10 @@ typedef struct DriverMsg {
 typedef struct Driver {
   int trainNum;
   int delayer;
-  int uiNagger;   // Tasks that reminds train to print
   int ui;        // Ui Tid
   int sensorWatcher;
   int trackManager;
-  int navigateNagger;
+  int nagger;
   int timeserver;
   int reportTime;
   int calibrationStart;
@@ -53,15 +51,33 @@ typedef struct Driver {
   int distancePassStopSensorToStop;
   int useLastSensorNow;
 
-  TrainUiMsg uiMsg;
+  //TrainUiMsg uiMsg;
   Poly decel;
   Route route;
 
   // TODO, non-ui stuff should use this instead of things instead of things in uiMsg
+  char lastSensorUnexpected;
+  char lastSensorBox;
+  char lastSensorVal;
+  int lastSensorActualTime;
+  int lastSensorPredictedTime;
+
+  int speed;      // 0 - 14
+  int speedDir;
+  int distanceFromLastSensor;
+  int distanceToNextSensor;
+
+  char nextSensorBox;
+  char nextSensorVal;
+  int nextSensorPredictedTime;
+
   Position currPos;
 
   int v[15][2];
   int d[15][2][2];
+
+  // UI stuff
+  char uiNth;
 } Driver;
 
 int startDriverControllerTask();
